# Part19 전처리기와 파일 분할 컴파일

## 19.1 전처리기(preprocesser)

![](https://images.velog.io/images/qmasem/post/8bbaa2f0-77e6-4fc8-8017-de23f264f6f2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.54.25.png)

### 전처리와 전처리기

- 소스 파일을 컴파일하기 전에 먼저 처리해야 하는 일이 있을 전처리라고 하고 전처리를 수행하는 장치를 전처리기라고 함

### 전처리기 지시자

- \# 문자로 시작하는 문장을 가르켜 전처리기 지시자라고 함
- 전처리기는 한 줄에 하나의 지시자만 사용하기 때문에 지시자 뒤에는 세미콜론을 사용하지 않음
  ex)

```c
#include <stdio.h>
```

---

## 19.2 매크로

\#define으로 시작되는 전처리 문장을 매크로라고 하며 매크로는 크게 매크로 상수와 매크로 함수로 나뉘어짐

### 매크로 상수

```c
#define PI 3.14
전처리기 지시자/매크로 상수 이름/매크로 상수에 치환되는 값을 지정
```

- 정수형 상수뿐만 아니라 실수형 상수, 문자열 상수, 함수 이름, 자료형도 매크로 상수로 정의 가능
- 유지보수에 용이하며 변수와 다리 추가적인 메모리 공간을 요구하지 않음

---

### 매크로 해제

```c
#undef PI
전처리기 지시자/해제할 매크로 이름
```

- 매크로는 한 번 정의하면 일관되게 사용하지만 기존 매크로를 재정의 하고 싶을 떄는 \#undef를 사용하기도 함

---

### 매크로 함수

```c
#define MUL(a, b) a*b
전처리기 지시자/매크로 함수 이름/함수의 기능
```

- 함수처럼 인자를 설정하는 있는 매크로
- 단순히 치환만 하므로 실제 함수는 아님
- 인자의 자료형을 신경쓰지 않음
- 함수의 몸체 부분이 매크로 함수의 치환 문장으로 대신하기 때문에 속도가 빠름
- 매크로 함수 내부에서 자기 자신을 호출할 수 없음
- 한 줄이나 두 줄 정도의 간단한 내용으로 정의해야 함
- 인자에 연산이 있다면 의도하는 대로 ()처리가 안되기에 직접 ()로 묶어줘야 하는 등 많은 점을 고려해야 함

---

### \# 연산자와 \## 연산자

- \# 연산자는 매크로 함수의 인자를 문자열로 바꾸어 주는 연산자
- \## 연산자는 토큰 결합 연산자라고 하며, 매크로 함수 안에서 토큰을 결합하는 기능 수행
- 프로그래밍 언어에서 토큰(Token)이란 문법 분석의 단위를 의미(컴파일러가 인식하는 문자나 문자열의 최소 단위), 토큰을 분석하는 프로그램을 파서(Parser)라고 하고 파서는 컴파일러에 포함되어 있음
- 파서는 코드의 문법을 해석하기 위해 코드를 숫자, 콤마, 연산자, 식별자 등의 토큰 단위로 분리하고 의미 파악

---

### 미리 정의된 매크로

![](https://images.velog.io/images/qmasem/post/a99392b9-8e06-407d-9673-cfacb93693d5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.36.00.png)

ex)

```c
#include <stdio.h>
int main(void)
{
    printf("File name: %s \n", __FILE__);
    printf("Row number: %d \n", __LINE__);
    printf("Compilation Date: %s \n", __DATE__);
    printf("Compile time: %s \n", __TIME__);

    return 0;
}

/*
File name: 19-10.c
Row number: 5
Compilation Date: Sep  1 2021
Compile time: 18:37:57
*/
```

---

## 19.3 조건부 컴파일

C 언어는 다양한 운영체제에서 사용되었기 때문에 각 운영체제가 제공하는 표준 함수나 동작이 다를 수 있음
이런 경우 소스 코드를 따로 작성하면 유지 보수의 용이성이 떨어지니 조건부 컴파일을 통해 해결할 수 있음

### \#if ~ \#endif

```c
#if(조건식)
	컴파일 문장
#endif
```

- 조건식에는 매크로 상수를 비교하는 산술 연산자, 관계 연산자, 논리 연산자 등을 사용할 수 있음

---

### \#if ~ \#else ~ \#endif

```c
#if(조건식)
	컴파일 문장1
#else
	컴파일 문장2
#endif
```

- 조건문 if else와 같이 if문이 참이면 컴파일 문장1, 거짓이면 컴파일 문장2를 수행

---

### \#if ~ \#elif ~ \#else ~ \#endif

```c
#if(조건식1)
	컴파일 문장1
#elif (조건식2)
	컴파일 문장2
#else
	컴파일 문장3
#endif
```

- if/else if/else 문과 같음

---

### \#ifdef ~ \#endif

```c
#ifdef 매크로 이름
	컴파일 문장
#endif
```

- \#ifdef: if defined, 매크로가 정의되어 있느냐만을 판단,매크로 상수 값에 의미를 두지 않음

---

### \#ifndef ~ \#endif

```c
#ifndef 매크로 이름
	컴파일 문장
#endif
```

- #ifndef: if not defined, 매크로가 정의되어 있지 않으면 컴파일 수행

---

## 19.4 파일 분할 컴파일

- 소스 파일을 여러 개로 분할하면 생산성이 높아지고 유지 보수에 용이함
- 외부 파일의 변수나 함수를 참조하기 위해선 extern 키워드를 사용

---

## 19.5 접근 금지 static 키워드

- 시스템 관련 중요한 변수나 함수는 extern 키워드로 참조하지 못하도록 static 키워드를 사용

---

## 19.6 \#include를 이용한 사용자 헤더 파일 만들기

- 표준 라이브러리는 <>로 감싼다면 사용자 정의 라이브러리는 ""로 감싼다
  ex) #include "사용자 정의 라이브러리"
- 헤더 파일의 중복 문제를 방지하지 위해 헤더 파일 시작과 끝에 #ifndef, #define, #endif 세 문장을 추가

---

Reference
강의: 박정민, 『C 프로그래밍』, KOCW 한국산업기술대학교, 18강
교재: 박정민, 『열혈강의 C 언어 본색 명강의가 일으키는 C 언어 기적』, 프리렉 (2011), p655-699.
