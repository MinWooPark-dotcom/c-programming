# Part11 다차원 배열이란 무엇인가

## 11.1 다차원 배열이란

- 2차원 이상의 배열을 의미
- 열의 길이는 반드시 설정, 열이 정해지면 자동으로 행을 조절할 수 있기 때문

### 2차원 배열의 선언

```c
int array[4][3];
자료형 배열이름 [행] [열](배열 길이);
```

- 자료형: 배열의 자료형을 지정
- 배열 이름: 배열을 구분하는 배열의 이름
- 배열 길이: 배열 요소의 길이를 행(가로)과 열(세로)로 지정

### 2차원 배열의 물리적 메모리 구조

![](https://images.velog.io/images/qmasem/post/446e4bc2-5c26-4633-a242-886645d3c2a6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-23%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.23.59.png)

물리적인 메모리 구조는 1차원이지만 이해하기 쉽도록 2차원으로 그림을 그리는 것도 좋음

---

## 11.2 2차원 배열의 주소와 값의 참조

### 2차원 배열의 다양한 주소 표현

- 2차원 배열 이름은 2차원 배열의 시작 주소
  ex)

```c
#include <stdio.h>
int main(void)
{
    int array[2][2] = {10, 20, 30, 40};

    printf("%x %x \n", array, array + 0); // ee7b1300 ee7b1300
    printf("%x \n", array + 1); // ee7b1308

    return 0;
}

```

- 2차원 배열의 행의 요소는 행을 대표하는 주소
  ex)

```c
#include <stdio.h>
int main(void)
{
    int array[2][2] = {10, 20, 30, 40};

    printf("%x %x \n", array[0], &array[0][0]); // 0행의 대표 주소 즉, 0행 0열의 주소,
    printf("%x %x \n", array[1], &array[1][0]); // 1행의 대표 주소 즉, 1행 0열의 주소

    return 0;
}

// e123d300 e123d300
// e123d308 e123d308
```

- 2차원 배열에서 array[i] == \*(array+i)는 주소를 표현
  ex)

```c
#include <stdio.h>
int main(void)
{
    int array[2][2] = {10, 20, 30, 40};

    printf("%x %x %x \n", array[0], *(array + 0), *array);
    printf("%x %x \n", array[1], *(array + 1));

    return 0;
}

// e6754300 e6754300 e6754300
// e6754308 e6754308
```

array[0]가 값이 아니라 0행을 대표하는 주소인 것처럼, \*array도 0행의 값이 아니라 0행을 대표하는 주소가 됨

---

### \*는 2차원 배열 요소에 저장된 값을 참조하는 연산자

ex)

```c
#include <stdio.h>
int main(void)
{
    int array[2][2] = {10, 20, 30, 40};

    printf("%d %d \n", *&array[0][0], *&array[0][1]);
    printf("%d %d \n", *&array[1][0], *&array[1][1]);
    printf("------\n");

    // 2차원 배열 요소를 먼저 연산하게 하고, 이후에 * 연산자로 값을 참조
    // array[i] + n에서 +n은 선언된 자료형의 크기만큼 더하라는 의미
    printf("%d %d \n", *(array[0] + 0), *(array[0] + 1));
    printf("%d %d \n", *(array[1] + 0), *(array[1] + 1));
    printf("------\n");

    // \*(array + i) == array[0]이므로 여기에 +n을 한 후 * 연산자로 값을 참조
    printf("%d %d \n", *(*(array + 0) + 0), *(*(array + 0) + 1));
    printf("%d %d \n", *(*(array + 1) + 0), *(*(array + 1) + 1));

    // 배열의 물리적 메모리는 한 줄로 되어 있음. *(array+0) 기준으로 12바이트  건너뛴 주소의 값
    // 논리적 주소로는 0행이 아니지만, 물리적 주소는 한 줄로 이루어졌기에 접근이 가능
    printf("%d \n", *(*(array+0) + 3)); // 40

    return 0;
}
```

---

Reference
강의: 박정민, 『C 프로그래밍』, KOCW 한국산업기술대학교, 11강
교재: 박정민, 『열혈강의 C 언어 본색 명강의가 일으키는 C 언어 기적』, 프리렉 (2011), p298-323.
